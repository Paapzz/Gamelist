name: Update HLTB Data

on:
  schedule:
    - cron: '0 4 * * *'  #7 утра
  workflow_dispatch:  

jobs:
  update-hltb:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
      with:
        token: ${{ secrets.PAT }}
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.x'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install aiohttp tqdm

    - name: Process HLTB data
      run: |
        python3 - <<EOF
        import json
        import math
        import asyncio
        import aiohttp
        import time
        import random
        from tqdm import tqdm

        CONCURRENT_REQUESTS = 5
        GAMES_TO_PROCESS = 10000
        BASE_DELAY = 1
        MAX_RETRIES = 5
        TIMEOUT = 30  # секунд
        SAVE_INTERVAL = 1000  # Сохранять каждые 1000 обработанных игр

        USER_AGENTS = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0'
        ]

        async def get_hltb_info(session, game, semaphore):
            async with semaphore:
                headers = {'User-Agent': random.choice(USER_AGENTS)}
                for attempt in range(MAX_RETRIES):
                    try:
                        game_title = game['name']
                        async with session.get(f'https://howlongtobeat.com/api/search?q={game_title}', headers=headers, timeout=TIMEOUT) as response:
                            if response.status == 200:
                                data = await response.json()
                                if data and len(data) > 0:
                                    game_info = max(data, key=lambda x: x.get('similarity', 0))
                                    return {
                                        "id": game['id'],
                                        "title": game_title,
                                        "main_story": game_info.get('main_story', 0),
                                        "main_extra": game_info.get('main_extra', 0),
                                        "completionist": game_info.get('completionist', 0)
                                    }
                            else:
                                print(f"Error fetching HLTB data for {game_title}: HTTP {response.status}")
                    except asyncio.TimeoutError:
                        print(f"Timeout error fetching HLTB data for {game_title}")
                    except Exception as e:
                        print(f"Error fetching HLTB data for {game_title}: {str(e)}")
                    
                    delay = BASE_DELAY * (2 ** attempt) + random.uniform(0, 1)
                    print(f"Retrying in {delay:.2f} seconds...")
                    await asyncio.sleep(delay)
                
                print(f"Failed to fetch HLTB data for {game_title} after {MAX_RETRIES} attempts")
                await asyncio.sleep(random.uniform(BASE_DELAY, BASE_DELAY * 2))
            return None

        async def process_hltb_data(games):
            hltb_data = []
            semaphore = asyncio.Semaphore(CONCURRENT_REQUESTS)
            async with aiohttp.ClientSession() as session:
                tasks = [get_hltb_info(session, game, semaphore) for game in games]
                for i, future in enumerate(tqdm(asyncio.as_completed(tasks), total=len(tasks), desc="Processing games")):
                    result = await future
                    if result:
                        hltb_data.append(result)
                    if (i + 1) % SAVE_INTERVAL == 0:
                        save_intermediate_results(hltb_data, i + 1)
            return hltb_data

        def save_intermediate_results(data, count):
            with open(f'data/hltb_intermediate_{count}.json', 'w') as f:
                json.dump(data, f)
            print(f"Saved intermediate results for {count} games")

        print("Loading games data...")
        all_games = []
        try:
            with open('data/index.json', 'r') as f:
                index = json.load(f)
            
            for i in range(1, index['total_files'] + 1):
                with open(f'data/games_{i}.json', 'r') as f:
                    games = json.load(f)
                    all_games.extend(games)
        except Exception as e:
            print(f"Error loading games data: {e}")
            exit(1)

        if not all_games:
            print("No games loaded. Exiting.")
            exit(1)

        # Сортируем игры по рейтингу (если есть) и берем топ GAMES_TO_PROCESS
        all_games.sort(key=lambda x: x.get('rating', 0), reverse=True)
        games_to_process = all_games[:GAMES_TO_PROCESS]

        print(f"Loaded {len(all_games)} games. Processing top {GAMES_TO_PROCESS} games.")
        print("Processing HLTB data...")
        start_time = time.time()
        try:
            hltb_data = asyncio.run(process_hltb_data(games_to_process))
        except asyncio.exceptions.CancelledError:
            print("Operation was cancelled. Saving partial results...")
        end_time = time.time()
        print(f"HLTB data processing took {end_time - start_time:.2f} seconds")
        print(f"Successfully processed {len(hltb_data)} games")

        hltb_per_file = 10000
        total_hltb_files = math.ceil(len(hltb_data) / hltb_per_file)

        print(f"Creating {total_hltb_files} HLTB file(s)...")

        for i in range(total_hltb_files):
            start = i * hltb_per_file
            end = min((i + 1) * hltb_per_file, len(hltb_data))
            with open(f'data/hltb_{i+1}.json', 'w') as f:
                json.dump(hltb_data[start:end], f)
            print(f"Created file data/hltb_{i+1}.json with {end - start} games")

        # Создаем индекс для HLTB данных
        hltb_index = {}
        for game in hltb_data:
            hltb_index[game['id']] = {
                'file': f"hltb_{math.floor(hltb_data.index(game) / hltb_per_file) + 1}.json",
                'index': hltb_data.index(game) % hltb_per_file
            }

        with open('data/hltb_index.json', 'w') as f:
            json.dump(hltb_index, f)
        print("Created hltb_index.json file")

        # Обновляем основной индекс
        index['total_hltb_files'] = total_hltb_files
        index['total_hltb_games'] = len(hltb_data)
        index['last_hltb_update'] = "$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
        with open('data/index.json', 'w') as f:
            json.dump(index, f)
        print("Updated index.json file with HLTB data")

        print("HLTB data processing complete!")
        EOF

    - name: Commit and push if changed
      run: |
        git config --global user.email "github-actions@github.com"
        git config --global user.name "GitHub Actions"
        git add data
        git diff --quiet && git diff --staged --quiet || (git commit -m "Update HLTB data" && git push)
